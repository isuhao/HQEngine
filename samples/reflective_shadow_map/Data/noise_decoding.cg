struct vOut{
	float4 position: POSITION;
	float2 texcoords: TEXCOORD0;
};

struct vIn{
	float4 position: VPOSITION;//zw contains width and height of render target
	float2 texcoords: VTEXCOORD0;
};

/*--------pass through vertex shader---------*/
vs_2_0 vs_3_0 vOut VS(in vIn input){
	vOut output;
	
	output.position = float4(input.position.xy, 0.0, 1.0);
	//half pixel offset
	float2 offset = 0.5 / input.position.zw;
	output.position.xy -= float2(offset.x, -offset.y);
	
	output.texcoords = input.texcoords;
	
	return output;
}


/*-----------pixel shader------------*/

uniform sampler2D encoded_noise_map: TEXUNIT0;

float4 PS(in float2 texcoords: TEXCOORD0): COLOR0{
	float4 encoded = tex2D(encoded_noise_map, texcoords);
	
	//pixel layout S2 = {A, R}, S1 = {G, B} 
	float S1, S2;
	
	S1 = encoded.b + encoded.g * 256.0;
	S1 /= 257.0;//scale down to [0..1]
	
	S2 = encoded.r + encoded.a * 256.0;
	S2 /= 257.0;//scale down to [0..1]
	
	float4 output;
	output.x = S1;
	output.y = S2; 
	output.z = 0.0; 
	output.w = 1.0;
	
	return output;
}